# 2.2 算法分析 #

## 2.2.1 蛮力轮询法 ##

1. 蛮力轮询指的的是对短字符串中的每一个字符在长字符串中进行轮询；
2. 由[*蛮力轮询.py*](http://)中的for循环逻辑可以看出，对长度为n的长字符串以及长度为m的短字符串进行蛮力轮询时其最差
时间复杂度为O(mn)，最优时间复杂度为O(n)；
2. 素数相乘法：素数相乘利用的是素数除了'1'与它本身外不能被其他数相除的特点，将所有
字符映射为唯一对应的素数，最后将长、短字符串中的每一个字符在字典中对应的素数各自相乘
若长字符串对短字符串（素数乘积）取余为0，则包含；否则，不包含. 通过其循环逻辑可知其
时间复杂度为O(m+n)；
3. 按位运算法：按位运算法的关键在于为字符串中的每一个不同的字符在二进制位上设计一个
签名（即为1），然后通过两个字符串的签名的按位与的结果来判断是否包含. 由其代码中的循
环逻辑可以看出其时间复杂度为2(m+n)，故其算法的时间复杂度为O(m+n).